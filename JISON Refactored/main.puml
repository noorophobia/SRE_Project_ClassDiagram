@startuml
package "Core" {

class CodeGenerator {
  - nextVariableId : int
  - variableTokens : string
  - variableTokensLength : int

  + tokenStackLex() : any
  + createVariable() : string
  + generateTableCode(table: any) : object
  + addTokenStack(fn: function) : string
  + removeErrorRecovery(fn: function) : string
}
class Generator {
  - options : object
  - terms : object
  - operators : object
  - productions : array
  - conflicts : int
  - resolutions : array
  - parseParams : any
  - yy : object
  - actionInclude : string
  - moduleInclude : string
  - DEBUG : boolean
  - terminals : array
  - lexer : object
  - nonterminals : object
  - symbols : array

  + constructor(grammar: any, opt: any)
  + processGrammar(grammar: any) : void
}
class GrammarProcessor {
    +processOperators
    +buildProductions(bnf, productions, nonterminals, symbols, operators, actionInclude, generator)
    +augmentGrammar(grammar, generator)
}
class Item {
    +production: Production
    +dotPosition: Number
    +follows: Array<String>
    +predecessor: Object
    +id: Number
    +markedSymbol: String
    +remainingHandle(): Array<String>
    +eq(e: Item): Boolean
    +handleToString(): String
    +toString(): String
}

class ItemSet {
    +reductions: Array
    +goes: Object
    +edges: Object
    +shifts: Boolean
    +inadequate: Boolean
    +hash_: Object
    +concat(set: ItemSet): ItemSet
    +push(item: Item): Number
    +contains(item: Item): Boolean
    +valueOf(): String
}
class Nonterminal {
    +symbol: String
    +productions: Set
    +first: Array<String>
    +follows: Array<String>
    +nullable: Boolean
    +toString(): String
}
class Parser {
    +trace(): void
    +warn(): void
    +error(msg: String): void
    +parseError(str: String, hash: Object): void
    +parse(input: String): Boolean
    +init(dict: Object): void
}
class Production {
    +symbol: String
    +handle: Array
    +nullable: Boolean
    +id: String
    +first: Array
    +precedence: Number
    +constructor(symbol: String, handle: Array, id: String)
    +toString(): String
}
class TableGenerator {
    +findDefaults(states: Array): Object
    +resolveConflict(production: Object, op: Object, reduce: Array, shift: Array): Object
}

class Utils {
    +each(obj: Object, func: Function): void
    +processOperators(ops: Array): Object
    +printAction(a: Array, gen: Object): String
}

 


}



package "Mixins" {
    class lookaheaddebug {
    +beforenullableSets(): void
    +beforefirstSets(): void
    +beforefollowSets(): void
    +afterfollowSets(): void
}
class LookaheadMixin {
    +computeLookaheads(): void
    +followSets(): void
    +first(symbol: string|Array): Array
    +firstSets(): void
    +nullableSets(): void
    +nullable(symbol: string|Array): boolean
}
class lrGenDebug {
    +beforeparseTable(): void
    +afterparseTable(): void
    +aftercanonicalCollection(states: Array): void
}
class lrGeneratorMixin {
    +buildTable(): void
    +Item: Item
    +ItemSet: ItemSet
    +closureOperation(itemSet: ItemSet): ItemSet
    +gotoOperation(itemSet: ItemSet, symbol: String): ItemSet
    +canonicalCollection(): Set
    +canonicalCollectionInsert(symbol: String, itemSet: ItemSet, states: Set, stateNum: int): void
    +parseTable(itemSets: Set): Array
}

}

package "Parsers" {
    class LALRGenerator {
    - type: String
    - states: Set
    - terms_: Object
    - newg: Object
    - inadequateStates: Array
    - onDemandLookahead: Boolean
    + constructor(grammar: Object, options: Object)
    + _initLookahead(): void
    + lookAheads(state: Object, item: Object): Array
    + go(p: String, w: Array): String
    + goPath(p: String, w: Array): Object
    + buildNewGrammar(): void
    + unionLookaheads(): void
}
class LLGenerator {
    - type: String
    - table: Object
    + constructor()
    + afterconstructor(): void
    + parseTable(productions: Array): Object
}
class LR0Generator {
    - type: String
    + constructor()
    + afterconstructor(): void
}
class LR1Generator {
    - type: String
    + lookAheads(state: ItemSet, item: Item): Array
    + afterconstructor(): void
}
class SLRGenerator {
    - type: String
    + lookAheads(state: ItemSet, item: Item): Array
    + afterconstructor(): void
}


}
package "Utils" {
    
' Define the Set class
class Set {
  -_items: array
  +Set_constructor(set: array, raw: boolean)
  +concat(setB: Set or array): Set
  +eq(set: Set): boolean
  +indexOf(item: any): number
  +union(set: Set): Set
  +intersection(set: Set): Set
  +complement(set: Set): Set
  +subset(set: Set): boolean
  +superset(set: Set): boolean
  +joinSet(set: Set): Set
  +contains(item: any): boolean
  +item(v: number, val: any): any
  +i(v: number, val: any): any
  +first(): any
  +last(): any
  +size(): number
  +isEmpty(): boolean
  +copy(): Set
  +toString(): string
  +push(...items: any[]): number
  +shift(): any
  +unshift(...items: any[]): number
  +forEach(callback: function): void
  +some(callback: function): boolean
  +every(callback: function): boolean
  +join(separator?: string): string
  +sort(compareFn?: function): Set
  +filter(callback: function): Set
  +slice(start?: number, end?: number): Set
  +map(callback: function): Set
  +union(a: array, b: array): array {static}
}
class typal {
    +mix(...objects): Object
    +beget(...objects): Object
    +construct(...objects): Function
    +constructor(): Object
}

}
Generator "1" *-- "*" Nonterminal : uses
Generator "1" *-- "*" Production : creates
Nonterminal --> Set : uses
Nonterminal --> typal : uses
GrammarProcessor --> Production : uses
GrammarProcessor --> Nonterminal : uses
GrammarProcessor --> Generator : modifies
Production --> typal : extends
Parser --> typal : extends
 
Parser --> Set : uses


 
lrGeneratorMixin --> Item

lrGeneratorMixin --> TableGenerator

LookaheadMixin --> Set: uses
LookaheadMixin --> Production: uses
LookaheadMixin --> Nonterminal: uses

lookaheaddebug --> Nonterminal: uses



SLRGenerator --|> Generator
SLRGenerator --> LookaheadMixin
SLRGenerator --> lrGeneratorMixin


LR1Generator --|> Generator
LR1Generator --> LookaheadMixin
LR1Generator --> lrGeneratorMixin
LR1Generator --> Item
LR1Generator --> ItemSet
LR1Generator --> Set

ItemSet --|> Set
LR0Generator --|> Generator
LR0Generator --> LookaheadMixin
LR0Generator --> lrGeneratorMixin



LLGenerator --|> Generator
LLGenerator --> Nonterminal
LLGenerator --> Production
LLGenerator --> Set
LLGenerator --> LookaheadMixin


LALRGenerator --|> Generator
LALRGenerator --> Nonterminal
LALRGenerator --> Production
LALRGenerator --> TableGenerator
@enduml


